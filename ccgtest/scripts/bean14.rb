class Root
	attr_accessor :sourceFile
	attr_accessor :targetBaseFolder

	attr_accessor :packages
	
	def initialize(sourceFile, targetBaseFolder, configElement)
		puts("Root")
		@sourceFile = sourceFile
		@targetBaseFolder = targetBaseFolder

		@packages = {}
		
		configElement.childElements("package").each {
			|packageElement|
			package = Package.new(self, packageElement)
			@packages[package.name] = package
		}
	end
	
	def resolve()
		@packages.each_value {
			|package|
			package.resolve()
		}
	end
	
	def write(monitor)
		puts("write Root")
		@packages.each_value {
			|package|
			package.write(monitor)
		}
	end
end

class Package
	attr_accessor :root
	attr_accessor :name
	attr_accessor :clean
	attr_accessor :folder
	
	attr_accessor :beans
	
	def initialize(root, configElement)
		puts("Package")
		@root = root
		@name = configElement.getRequiredAttribute("name")
		@clean = configElement.getAttributeAsBoolean("clean")
		
		folderPath = @name.gsub('.', '/')
		@folder = @root.targetBaseFolder.getFolder(folderPath)
		puts("package.folder is #{folder.fullPath}")

		@beans = {}
		
		configElement.getChildElements("bean").each {
			|beanElement|
			bean = Bean.new(self, beanElement)
			@beans[bean.name] = bean
		}
	end
	
	def resolve()
		@beans.each_value {
			|bean|
			bean.resolve()
		}
	end
	
	def write(monitor)
		puts("write Package #{name}")
		files = Array.new
		@beans.each_value {
			|bean|
			content = bean.file.createContentBuffer()
			content.p("package " + @name + ";")
			content.p()
			bean.write(content, monitor)
			bean.file.write(content.content, true, monitor)
			files << bean.file
		}
		if @clean
			puts("clean Package #{name} NYI")
			members = @folder.members();
			members.each {
				|member|
				if member.isFile() && member.isDerived() && !files.include?(member)
					member.delete(false, monitor)
				end
			}
		end
	end
end

class Bean
	attr_accessor :package
	attr_accessor :name
	attr_accessor :file

	attr_accessor :properties
	
	def initialize(package, configElement)
		puts("Bean")
		@package = package
		@name = configElement.getRequiredAttribute("name")
		
		@file = @package.folder.getFile(@name + ".java")
		puts("bean.file is #{file.fullPath}")

		@properties = {}
		
		configElement.getChildElements("property").each {
			|propertyElement|
			cardinality = propertyElement.getAttribute("cardinality", "1")
			if cardinality == "1"
				property = SingleProperty.new(self, propertyElement)
			elsif cardinality == "*"
				property = MultiProperty.new(self, propertyElement)
			else
				raise "invalid kind: #{kind}"
			end
			@properties[property.name] = property
		}
	end
	
	def resolve()
		@properties.each_value {
			|property|
			property.resolve()
		}
	end
	
	def write(content, monitor)
		puts("write Bean #{name}")
		content.pi("/**", " * ")
		content.p("Generated by EasyCodeGen: #{package.root.sourceFile.fullPath}")
		content.pu(" */")
		content.pi("public class #{name} {")
		@properties.each_value {
			|property|
			property.write(content, monitor)
			content.p()
		}
		content.pu("}")
	end
end

class Property
	attr_accessor :bean
	attr_accessor :name
	attr_accessor :varName
	attr_accessor :capName
	attr_accessor :type
	attr_accessor :backref
	attr_accessor :backrefProperty
	attr_accessor :getterVisibility
	attr_accessor :setterVisibility

	def initialize(bean, configElement)
		@bean = bean
		@name = configElement.getAttribute("name")
		@varName = "_#{name}"
		@capName = @name.dup
		@capName[0,1] = @capName[0,1].upcase
		@type = configElement.getAttribute("type")
		@backref = configElement.getAttribute("backref")
		@getterVisibility = "public"
		@setterVisibility = "public"
	end
	
	def resolve()		
		if !@backref.nil?
			@backrefProperty = @bean.package.beans[@type].properties[@backref]
			if @backrefProperty.nil?
				raise "Unknown backref #{@backref}"
			end
			if !@backrefProperty.backrefProperty.nil? and @backrefProperty.backrefProperty != self
				raise "Backref of backref #{@backref} is not #{@name}, but #{@backrefProperty.backrefProperty.name}"
			end
			puts("backref of #{@bean.name}.#{@name} is #{@backrefProperty.bean.name}.#{@backrefProperty.name}")
		end
	end
	
	def getNameConstant()
		return "PROPERTY_#{@name.upcase()}_NAME"
	end
	
	def getTypeConstant()
		return "PROPERTY_#{@name.upcase()}_TYPE"
	end
	
	def getJavaDocFullName()
		return "{@link #{@bean.package.name}.#{@bean.name}\##{@varName}}"
	end
end

class SingleProperty < Property
	attr_accessor :getterPrefix
	
	def initialize(bean, configElement)
		super
		if @type == "boolean"
			@getterPrefix = "is"
		else
			@getterPrefix = "get"
		end
	end
	
	def getAdderCall(instance, value)
		return "#{instance}.set#{@capName}(#{value});"
	end
	
	def getRemoverCall(instance, value)
		return "#{instance}.set#{@capName}(null);"
	end
	
	def write(content, monitor)
		#
		# constants
		#
		content.pi("/**", " * ")
		content.p("Single-Property name constant.")
		if !@backrefProperty.nil?
			content.p("Ref from #{@backrefProperty.getJavaDocFullName()}")
		end
		content.pu(" */")
		content.p("public static final String #{getNameConstant()} = \"#{@name}\";")
		content.p("public static final Class #{getTypeConstant()} = #{@type}.class;")
		
		#
		# variable
		#
		content.p()
		content.p("private #{@type} #{@varName};")
		
		#
		# getter
		#
		content.p()
		content.pi("#{@getterVisibility} final #{@type} #{@getterPrefix}#{@capName}() {")
		
		content.p("return #{@varName};")
		
		content.pu("}")
		
		#
		# setter
		#
		content.p()
		content.pi("#{@setterVisibility} final void set#{@capName}(final #{@type} #{@name}) {")
		
		if @backrefProperty.nil?
			content.p("#{@varName} = #{@name};")
		else
			content.pi("if (#{@varName} == #{@name}) {")
			content.p("return;")
			content.pu("}")
			oldName = "old#{@capName}"
			content.p("#{@type} #{oldName} = #{@varName};")
			content.pi("if (#{@varName} != null) {")
			content.p("#{@varName} = null;")
			content.p(@backrefProperty.getRemoverCall(oldName, "this"))
			content.pu("}")
			content.p("#{@varName} = #{@name};")
			content.pi("if (#{@name} != null) {")
			content.p(@backrefProperty.getAdderCall(@name, "this"))
			content.pu("}")
		end
		
		content.pu("}")
	end
end

class MultiProperty < Property
	def initialize(bean, configElement)
		super
	end
	
	def getAdderCall(instance, value)
		return "#{instance}.add#{@capName}(#{value});"
	end
	
	def getRemoverCall(instance, value)
		return "#{instance}.remove#{@capName}(#{value});"
	end
	
	def write(content, monitor)
		#
		# constants
		#
		content.pi("/**", " * ")
		content.p("Multi-Property name constant.")
		if !@backrefProperty.nil?
			content.p("Ref from #{@backrefProperty.getJavaDocFullName()}")
		end
		content.pu(" */")
		content.p("public static final String #{getNameConstant()} = \"#{@name}\";")
		content.p("public static final Class #{getTypeConstant()} = #{@type}.class;")
		
		#
		# variable
		#
		content.p()
		content.p("private final java.util.List #{@varName} = new java.util.ArrayList();")
		
		#
		# getter
		#
		content.p()
		content.pi("#{@getterVisibility} final #{@type} get#{@capName}(int index) {")
		
		content.p("return (#{@type}) #{@varName}.get(index);")
		
		content.pu("}")
		
		content.p()
		content.pi("#{@getterVisibility} final java.util.Iterator #{@name}Iterator() {")
		
		content.p("return #{@varName}.iterator();")
		
		content.pu("}")
		
		content.p()
		content.pi("#{@getterVisibility} final int #{@name}Size() {")
		
		content.p("return #{@varName}.size();")
		
		content.pu("}")
		
		#
		# adder
		#
		content.p()
		content.pi("#{@setterVisibility} final void add#{@capName}(final #{@type} #{@name}) {")
		
		if @backrefProperty.nil?
			content.p("#{@varName}.add(#{@name});")
		elsif @backrefProperty.backrefProperty.nil?
			content.p("#{@varName}.add(#{@name});")
			content.p(@backrefProperty.getAdderCall(@name, "this"))
		else
			content.pi("if (#{@varName}.contains(#{@name})) {")
			content.p("return;")
			content.pu("}")
			content.p("#{@varName}.add(#{@name});")
			content.p(@backrefProperty.getAdderCall(@name, "this"))
		end
		
		content.pu("}")
		
		#
		# remover
		#
		content.p()
		content.pi("#{@setterVisibility} final void remove#{@capName}(final #{@type} #{@name}) {")
		
		if @backrefProperty.nil?
			content.p("#{@varName}.remove(#{@name});")
		elsif @backrefProperty.backrefProperty.nil?
			content.p("#{@varName}.remove(#{@name});")
			content.p(@backrefProperty.getRemoverCall(@name, "this"))
		else
			content.pi("if (!#{@varName}.contains(#{@name})) {")
			content.p("return;")
			content.pu("}")
			content.p("#{@varName}.remove(#{@name});")
			content.p(@backrefProperty.getRemoverCall(@name, "this"))
		end
		
		content.pu("}")
	end
end
